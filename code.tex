\section{Details of the Code}
\label{Code}
\subsection{Directory structure}
The directory structure is as shown in Fig.\ \ref{fdirs}, with the
ability to run the ocean alone or coupled to atmospheric and/or
wave models. If running just the ocean, the model can be run forward
in time (the Nonlinear model) or as an adjoint, tangent linear, or
representer model for data assimilation purposes. This document
describes the uncoupled forward model only.

\subsection{Main subroutines}

\subsubsection{master.F}
The main program is in \code{master.F}. It is simply a shell, including
one of \code{mct\_coupler.h}, \code{esmf\_coupler.h} or \code{ocean.h}. In
our case, \code{ocean.h} contains the actual main program, which
initializes MPI (if needed), calls \code{ROMS\_initialize}, then
calls \code{ROMS\_run} with arguments for how many steps to take,
then \code{ROMS\_finalize}, then finally wraps up the MPI.

\subsubsection{ocean\_control.F}
This is again a shell which includes one of many other files to do
the actual work. In this case, the worker files all contain
\code{ROMS\_initialize}, \code{ROMS\_run} and \code{ROMS\_finalize}
and live in the \code{ROMS/Drivers} directory. The driver file we
will be looking at is \code{nl\_ocean.h}.

\subsubsection{ROMS\_initialize}
This is called at the beginning of the run and therefore starts off
by finding out how many parallel processes are running and which one
this is before doing anything else. 

calls the initialization routines and then calls either \code{main3d}
or \code{main2d}.  A flow chart for \code{main3d} is shown in Fig.\
\ref{flow}.  The boxes refer to subroutines which are described as
follows:

\begin{figure}
\thinlines
\begin{center}
\setlength{\unitlength}{3947sp}%
%
\begin{picture}(4824,8724)(3589,-8773)
\thinlines
\put(4801,-8461){\line( 0,-1){300}}
\put(4801,-8761){\line(-1, 0){1200}}
\put(3601,-8761){\line( 0, 1){7500}}
\put(3601,-1261){\vector( 1, 0){1200}}
\put(4801,-961){\vector( 0,-1){600}}
\put(4201,-1861){\framebox(1200,300){}}
\put(4801,-1861){\vector( 0,-1){300}}
\put(4201,-2461){\framebox(1200,300){}}
\put(4201,-3061){\framebox(1200,300){}}
\put(4201,-3661){\framebox(1200,300){}}
\put(4201,-4261){\framebox(1200,300){}}
\put(4201,-4861){\framebox(1200,300){}}
\put(4801,-2461){\vector( 0,-1){300}}
\put(4201,-5461){\framebox(1200,300){}}
\put(4801,-3061){\vector( 0,-1){300}}
\put(4201,-6061){\framebox(1200,300){}}
\put(4801,-5461){\vector( 0,-1){300}}
\put(4801,-6061){\line( 0,-1){225}}
\put(4801,-6286){\line( 1, 0){1200}}
\put(6001,-6286){\line( 0, 1){2025}}
\put(6001,-4261){\line( 1, 0){1200}}
\put(7201,-4261){\vector( 0,-1){300}}
\put(6601,-4861){\framebox(1200,300){}}
\put(6601,-5461){\framebox(1200,300){}}
\put(7201,-5461){\vector( 0,-1){300}}
\put(7201,-4861){\vector( 0,-1){300}}
\put(4801,-4861){\vector( 0,-1){300}}
\put(4801,-4261){\vector( 0,-1){300}}
\put(4801,-3661){\vector( 0,-1){300}}
\put(6601,-6061){\framebox(1200,300){}}
\put(6601,-6661){\framebox(1200,300){}}
\put(7201,-6061){\vector( 0,-1){300}}
\put(6601,-7261){\framebox(1200,300){}}
\put(7201,-6661){\vector( 0,-1){300}}
\put(7201,-7261){\line( 0,-1){225}}
\put(7201,-7486){\line( 1, 0){1200}}
\put(8401,-7486){\line( 0, 1){3150}}
\put(8401,-4336){\line(-1, 0){1200}}
\put(7201,-4336){\vector( 0,-1){225}}
\put(4201,-7261){\framebox(1200,300){}}
\put(4201,-7861){\framebox(1200,300){}}
\put(4201,-8461){\framebox(1200,300){}}
\put(4801,-7261){\vector( 0,-1){300}}
\put(4801,-7861){\vector( 0,-1){300}}
\put(7201,-7261){\line( 0,-1){300}}
\put(7201,-7561){\line(-1, 0){1200}}
\put(6001,-7561){\line( 0, 1){825}}
\put(6001,-6736){\line(-1, 0){1200}}
\put(4801,-6736){\vector( 0,-1){225}}
\put(4276,-961){\framebox(1125,300){}}
\put(4276,-361){\framebox(1125,300){}}
\put(4801,-361){\vector( 0,-1){300}}
\put(4801,-1786){\makebox(0,0)[b]{\code{set\_vbc}}}
\put(4801,-2386){\makebox(0,0)[b]{\code{depth3d}}}
\put(4801,-2986){\makebox(0,0)[b]{\code{omega}}}
\put(4801,-3586){\makebox(0,0)[b]{\code{prsgrd}}}
\put(4801,-4186){\makebox(0,0)[b]{\code{u3drhs}}}
\put(4801,-4786){\makebox(0,0)[b]{\code{v3drhs}}}
\put(4801,-5386){\makebox(0,0)[b]{\code{trhs}}}
\put(4801,-5986){\makebox(0,0)[b]{\code{frc2drhs}}}
\put(7201,-4786){\makebox(0,0)[b]{\code{zetarhs}}}
\put(7201,-5386){\makebox(0,0)[b]{\code{u2drhs}}}
\put(7201,-5986){\makebox(0,0)[b]{\code{v2drhs}}}
\put(7201,-6586){\makebox(0,0)[b]{\code{step2d}}}
\put(7201,-7186){\makebox(0,0)[b]{\code{depth2d}}}
\put(4801,-7186){\makebox(0,0)[b]{\code{vert\_mix}}}
\put(4801,-7786){\makebox(0,0)[b]{\code{step3d}}}
\put(4801,-8386){\makebox(0,0)[b]{\code{rho\_eos}}}
\put(7576,-4261){\makebox(0,0)[lb]{{loop over short steps}}}
\put(4801,-886){\makebox(0,0)[b]{\code{initial}}}
\put(4801,-286){\makebox(0,0)[b]{\code{inp\_par}}}
\end{picture}
\end{center}
\caption{Flow chart of the model main program.}
\label{flow}
\end{figure}

\begin{figure}[tbp]
\begin{center}
\setlength{\unitlength}{3947sp}%
%
\begin{picture}(2724,10074)(3439,-10123)
\thinlines
\put(4201,-7111){\framebox(1200,300){}}
\put(4201,-8311){\framebox(1200,300){}}
\put(4201,-8911){\framebox(1200,300){}}
\put(4801,-8311){\vector( 0,-1){300}}
\put(4801,-8911){\vector( 0,-1){300}}
\put(4801,-9511){\vector( 0,-1){300}}
\put(4201,-7711){\framebox(1200,300){}}
\put(4801,-7711){\vector( 0,-1){300}}
\put(4801,-7111){\vector( 0,-1){300}}
\put(4801,-6061){\line( 4, 3){600}}
\put(5401,-5611){\line(-4, 3){600}}
\put(4801,-5161){\line(-4,-3){600}}
\put(4201,-5611){\line( 4,-3){600}}
\put(4801,-4861){\vector( 0,-1){300}}
\put(4201,-4861){\framebox(1200,300){}}
\put(3451,-6511){\framebox(1200,300){}}
\put(4951,-6511){\framebox(1200,300){}}
\put(5326,-6511){\vector(-1,-1){300}}
\put(4276,-6511){\vector( 1,-1){300}}
\put(4576,-5911){\vector(-1,-1){300}}
\put(5026,-5911){\vector( 1,-1){300}}
\put(4201,-9511){\framebox(1200,300){}}
\put(3901,-10111){\framebox(1800,300){}}
\put(4801,-8236){\makebox(0,0)[b]{\code{omega}}}
\put(4801,-8836){\makebox(0,0)[b]{\code{set\_vbc}}}
\put(4801,-7636){\makebox(0,0)[b]{\code{depth3d}}}
\put(4801,-7036){\makebox(0,0)[b]{\code{depth2d}}}
\put(4801,-5686){\makebox(0,0)[b]{{initial file?}}}
\put(4276,-5986){\makebox(0,0)[b]{{no}}}
\put(5401,-5986){\makebox(0,0)[b]{{yes}}}
\put(4801,-4786){\makebox(0,0)[b]{\code{set\_scoord}}}
\put(5551,-6436){\makebox(0,0)[b]{\code{get\_initial}}}
\put(4051,-6436){\makebox(0,0)[b]{\code{ana\_initial}}}
\put(4801,-9436){\makebox(0,0)[b]{\code{rho\_eos}}}
\put(4801,-10036){\makebox(0,0)[b]{{initialize output files}}}
\put(4801,-1561){\line( 4, 3){600}}
\put(5401,-1111){\line(-4, 3){600}}
\put(4801,-661){\line(-4,-3){600}}
\put(4201,-1111){\line( 4,-3){600}}
\put(4801,-361){\vector( 0,-1){300}}
\put(4201,-361){\framebox(1200,300){}}
\put(4201,-2611){\framebox(1200,300){}}
\put(4801,-2611){\vector( 0,-1){300}}
\put(3451,-2011){\framebox(1200,300){}}
\put(4951,-2011){\framebox(1200,300){}}
\put(4276,-2011){\vector( 1,-1){300}}
\put(5326,-2011){\vector(-1,-1){300}}
\put(5026,-1411){\vector( 1,-1){300}}
\put(4576,-1411){\vector(-1,-1){300}}
\put(3451,-4261){\framebox(1200,300){}}
\put(4951,-4261){\framebox(1200,300){}}
\put(4276,-4261){\vector( 1,-1){300}}
\put(4576,-3661){\vector(-1,-1){300}}
\put(5326,-4261){\vector(-1,-1){300}}
\put(5026,-3661){\vector( 1,-1){300}}
\put(4779,-3795){\line( 4, 3){600}}
\put(5379,-3345){\line(-4, 3){600}}
\put(4779,-2895){\line(-4,-3){600}}
\put(4179,-3345){\line( 4,-3){600}}
\put(4801,-1186){\makebox(0,0)[b]{{grid file?}}}
\put(5401,-1486){\makebox(0,0)[b]{{yes}}}
\put(4276,-1486){\makebox(0,0)[b]{{no}}}
\put(4801,-2536){\makebox(0,0)[b]{\code{metrics}}}
\put(4051,-1936){\makebox(0,0)[b]{\code{ana\_grid}}}
\put(5551,-1936){\makebox(0,0)[b]{\code{get\_grid}}}
\put(4801,-286){\makebox(0,0)[b]{\code{zero\_arrays}}}
\put(5551,-4186){\makebox(0,0)[b]{\code{get\_mask}}}
\put(4051,-4186){\makebox(0,0)[b]{\code{ana\_mask}}}
\put(4276,-3736){\makebox(0,0)[b]{{no}}}
\put(5401,-3736){\makebox(0,0)[b]{{yes}}}
\put(4801,-3436){\makebox(0,0)[b]{{mask file?}}}
\end{picture}
\end{center}
\caption{Flow chart of the \code{initial} subroutine.}
\label{finit}
\end{figure}

\begin{klist}
  \kitem{depth2d}  Computes the  evolving total depth of the water
column that is associated with the 2-D momentum equations. It
also computes the  coefficients  used in the  advection  and
viscosity of 2-D momentum.
  \kitem{depth3d}  Computes the evolving depths of the model grid and
its associated vertical transformation metric $H_z$. It also computes
the coefficients which contain $H_z$ and are used in the  horizontal
advection of momentum and tracers and in the horizontal mixing.
  \kitem{frc2drhs} Computes the forcing terms
($R_{u_{\rm slow}},R_{v_{\rm slow}}$) for the 2-D momentum
equations which are
held constant over the short time steps.  These forcing terms
contains the vertically integrated  terms  from the  3-D momentum
equations which are not considered in the 2-D equations.
  \kitem{initial}     Does everything that needs to be done to start up
the model run.  It reads initial parameters and $u, v, T, S$, and
$\zeta$ fields from disk or calls \code{ana\_initial}.  It then
calculates the remaining initial fields and opens the restart file.
The flow chart for \code{initial} is shown in Fig.\ \ref{finit}.
   \kitem{inp\_par}  Reads in input model parameters from standard
input.  It also writes out these parameters to standard output and
calls \code{checkdefs}.
  \kitem{omega}   Calculates the scaled vertical velocity
$H_z \Omega/mn$ according to equation (\ref{omega}).
  \kitem{prsgrd}   Calculates the horizontal pressure gradients
according to equation (\ref{prgs}).
  \kitem{rho\_eos}   Calculates the density anomaly, $\rho$, using the
equation of state (\S\ref{EOS}).
  \kitem{set\_vbc} Sets the vertical boundary conditions
for momentum and tracers.
  \kitem{step2d}  Time steps free-surface and 2-D momentum
equations.  Also does the time-averaging described in \S\ref{Vort} and
calls the 2-D boundary condition routines.
  \kitem{step3d}  Time steps the 3-D momentum and tracers
(usually potential temperature and salinity),
using the tridiagonal solver described in \S\ref{Vfric}.
Couples 3-D and 2-D momentum fields. It computes and
removes the vertical means from the newly computed 3-D
velocities and replaces those means with the more accurate 2-D
velocities. It also calls the boundary condition routines.
  \kitem{trhs}   Calculates and stores contributions to the
right-hand-side of the tracer equations (\ref{st15}) and \ref{st16}),
where the advective terms have been moved to the right-hand-side.
  \kitem{u2drhs}     Calculates and stores contributions
to the right-hand-side of equation (\ref{ubar2}), where all the terms
other than $\frac{\partial}{\partial t} (\frac{Du}{mn})$
have been moved to the right-hand-side.
  \kitem{u3drhs}     Calculates and stores contributions
to the right-hand-side of equation (\ref{st13}), where all the terms
other than $\frac{\partial}{\partial t} (\frac{H_zu}{mn})$
have been moved to the right-hand-side.
  \kitem{v2drhs}     Calculates and stores contributions
to the right-hand-side of equation (\ref{vbar2}), where all the terms
other than $\frac{\partial}{\partial t} (\frac{Dv}{mn})$
have been moved to the right-hand-side.
  \kitem{v3drhs}     Calculates and stores contributions
to the right-hand-side of equation (\ref{st14}), where all the terms
other than $\frac{\partial}{\partial t} (\frac{H_zv}{mn})$
have been moved to the right-hand-side.
  \kitem{vert\_mix} Computes the vertical mixing coefficients
for momentum (\code{Akv}) and tracers (\code{Akt}).
  \kitem{zetarhs}   Computes the right-hand-side of
equation (\ref{zeta1}), where all the terms
other than $\frac{\partial}{\partial t} (\frac{\zeta}{mn})$
have been moved to the right-hand-side.
\end{klist}

\subsection{Other subroutines and functions}
\label{Minor}
\begin{klist}
  \kitem{Initialization} \mbox{\hspace{1in}}
   \begin{klist}
     \kitem{ana\_grid}  Sets up an analytic grid.
     \kitem{ana\_initial}  Sets up analytic initial conditions.
     \kitem{ana\_mask}  Sets up an analytic mask.
     \kitem{blkdat}     Initializes some variables and
   parameters stored in common blocks.
     \kitem{checkdefs}Reports on which C preprocessor variables
   have been \code{\#define}d and checks their consistency.
     \kitem{get\_grid} Reads in the curvilinear coordinate arrays as
   well as $f$ and $h$ from a grid netCDF file.
     \kitem{get\_initial} Reads initial fields from disk---either
   restart or initializing from a climatology.
     \kitem{get\_mask} Reads in the mask arrays from
   the grid netCDF file.  It also adjusts \code{pmask} as required for
   the free-slip/no-slip boundary conditions as described in
   \S\ref{Mask1}.
     \kitem{metrics}   Computes the metric term combinations which do
   not depend on the surface elevation and therefore remain constant in
   time.
     \kitem{set\_scoord}  Sets and initializes relevant variables
   associated with the vertical transformation to nondimensional
   $s$-coordinate described in Appendix~\ref{Scoord}.
     \kitem{zero\_arrays} Initializes (zeroes out) various arrays.
   \end{klist}
\kitem{NetCDF I/O} \mbox{\hspace{1in}}
   \begin{klist}
     \kitem{def\_avg}    Creates the SCRUM averages NetCDF file and
   defines its dimensions, attributes, and variables.
     \kitem{def\_his}    Creates the SCRUM history NetCDF file and
   defines its dimensions, attributes, and variables.
     \kitem{def\_rst}    Creates the SCRUM restart NetCDF file and
   defines its dimensions, attributes, and variables.
     \kitem{def\_station} Creates the SCRUM station NetCDF file and
   defines its dimensions, attributes, and variables.
     \kitem{get\_date}   Gets today's date, day of the week and time
   called.  It uses Sun's intrinsic \code{date} routine by default.
     \kitem{lenstr}  Returns the character position of the last
   non-blank character in a ``string'' after removing the leading blank
   characters, if any.  Should not be called with a literal string
   argument.
     \kitem{opencdf}     Opens an existing NetCDF file, inquires
   about its contents, and checks for consistency with model dimensions.
     \kitem{wrt\_avg}    Writes SCRUM time-averaged fields into the
   averages NetCDF file.
     \kitem{wrt\_his}    Writes requested SCRUM fields at requested
   levels into the history NetCDF file.
     \kitem{wrt\_rst}    Writes SCRUM fields into the restart NetCDF
   file.
     \kitem{wrt\_station} Writes out data into the stations NetCDF file.
   \end{klist}
\kitem{Forcing fields} The file \code{analytic.F} contains analytical
formulations for computing various forcings and initializations.
For more realistic problems these fields are read from NetCDF files.
   \begin{klist}
     \kitem{ana\_bmflux}  Computes analytic kinematic bottom
   momentum flux.
     \kitem{ana\_btflux}  Computes analytic kinematic bottom flux of
   tracer type variables.
     \kitem{ana\_smflux}  Computes analytic kinematic surface
   momentum flux (wind stress).
     \kitem{ana\_srflux}  Computes analytic kinematic surface
   shortwave radiation.
     \kitem{ana\_ssh}  Computes analytic sea surface height
   and dQdSST which are used in the surface heat flux correction.
     \kitem{ana\_sst}  Computes analytic sea surface temperature
   and dQdSST which are used in the surface heat flux correction.
     \kitem{ana\_stflux}  Computes analytic kinematic surface
   flux of tracer type variables.
     \kitem{ana\_tclima}  Computes analytic tracer climatology fields.
     \kitem{get\_bmflux}  Reads bottom momentum flux (bottom stress)
   from the forcing NetCDF file, and then linearly
   time-interpolates to current model time.
     \kitem{get\_btflux}  Reads bottom flux of  tracer type variables
   from the forcing NetCDF file, and then linearly
   time-interpolates to current model time.
     \kitem{get\_cycle}   Determines relevant parameters for time
   cycling of data from the forcing NetCDF file.  For instance, you may
   wish to use monthly means for each year of a multi-year run.
     \kitem{get\_smflux}  Reads surface  momentum  flux (wind stress)
   from the forcing NetCDF file, and then linearly
   time-interpolates to current model time.
     \kitem{get\_srflux}  Reads shortwave radiation flux
   from the forcing NetCDF file, and then linearly
   time-interpolates to current model time.
     \kitem{get\_ssh}  Reads sea surface height
   from the forcing NetCDF file and then linearly
   time-interpolates to current model time.
     \kitem{get\_sst}  Reads sea surface temperature and surface net
   heat flux sensitivity to sea surface temperature from the forcing
   NetCDF file and then linearly time-interpolates to current model
   time.
     \kitem{get\_stflux}  Reads surface flux of tracer type variables
   from the forcing NetCDF file, and then linearly
   time-interpolates to current model time.
     \kitem{get\_tclima}  Reads climatology of tracer type variables
   from the climatology NetCDF file, and then linearly
   time-interpolates to current model time.
     \kitem{set\_nudgcof} Set nudging coefficients time-scales (1/s).
   \end{klist}
\kitem{Horizontal mixing} The horizontal mixing routines have options
for doing Laplacian or biharmonic mixing, along surfaces of constant
$s$, $z$, or density, as described in \S\ref{Smooth}.
The horizontal mixing of 2-D momentum is computed in \code{u2drhs} and
\code{v2drhs}.
   \begin{klist}
     \kitem{get\_epislope} Computes the epineutral slopes
   (nondimensional) used in the mixing tensor rotation relative
   to geopotential surfaces.
     \kitem{get\_isoslope} Computes the isopycnal slopes
   (nondimensional) used in the mixing tensor rotation relative
   to geopotential surfaces.
     \kitem{set\_hmixing} Sets horizontal mixing coefficients.  If
   requested, it also scales horizontal mixing by the grid size and
   enhances horizontal mixing in the sponge areas.
     \kitem{shapd}   Applies a 2-D Shapiro filter to an array.
     \kitem{smagorinsky} This routine computes horizontal mixing
   coefficients for momentum using Smagorinsky parameterization (Tag et
   al.\ \cite{Tag79}).
     \kitem{t3dmix}  Computes horizontal mixing of tracer type
   variables.
     \kitem{u3dmix}  Computes horizontal mixing of the 3-D momentum
   component in the $\xi$-direction.
     \kitem{v3dmix}  Computes horizontal mixing of the 3-D momentum
   component in the $\eta$-direction.
   \end{klist}
\kitem{Vertical mixing} The model contains a variety of methods for
computing the vertical mixing coefficients \code{Akt} and \code{Akv},
including an analytic formula.
   \begin{klist}
     \kitem{ana\_vmix} Computes analytic vertical mixing coefficients
   for momentum and tracers.
     \kitem{bv\_freq}  Computes the squared Brunt-V\"ais\"al\"a
   frequency at $w$-points $N^2 = - {g \over \rho_o} {\partial \rho
   \over \partial z}$.
     \kitem{lmd\_vmix} Computes vertical mixing coefficients for
   momentum 
   and tracers at the ocean interior using the  Large,  McWilliams
   and Doney \cite{Large94} mixing scheme.
     \begin{klist}
     \kitem{lmd\_bldepth} Determines the oceanic planetary boundary
   layer depth,  \code{hbl}, as the shallowest depth where the bulk
   Richardson number is equal to the critical value, \code{Ric}.
     \kitem{lmd\_blmix}  Sets the vertical mixing coefficients within
   the boundary layer.
     \kitem{lmd\_swfrac} Computes the  fraction  of  solar shortwave
   flux penetrating to specified depth (times Zscale) due to
   exponential decay in Jerlov water type.
     \kitem{lmd\_wscale} Computes the turbulent velocity scale for
   momentum and tracers using a 2-D lookup table as a function of
   \code{ustar} and \code{zetahat}.
     \end{klist}
     \kitem{my25\_vmix}  Computes vertical mixing coefficients for
   momentum and tracers using the Mellor and Yamada \cite{Mellor74}
   mixing level 2.5 scheme with modifications described in Galperin et
   al.\ \cite{Galperin88}.
     \begin{klist}
     \kitem{my25\_q}   Solves the prognostic equation for turbulent
   energy variables used in the  Mellor-Yamada level 2.5
   turbulent closure.
     \end{klist}
     \kitem{pp\_vmix}   Computes vertical mixing coefficients for
   momentum and tracers using the  Pacanowski and Philander
   \cite{Pacanowski81} mixing scheme which is based on the Richardson
   number.
     \kitem{ri\_number} Computes the gradient Richardson number for
   the vertical mixing schemes.
     \kitem{trisolver}  Solves the PDE
   $A \phi(k-1) + B \phi(k) + C \phi(k+1) = D$
     for field $\phi$ using the tridiagonal solver, also known as
  Thomas algorithm (Richtmeyer and Morton \cite{Richtmeyer}).
   \end{klist}
\kitem{Bottom boundary-layer model} The model has an optional bottom
boundary layer based on Styles and Glenn \cite{Styles96}.
   \begin{klist}
     \kitem{ana\_bsedim}  Computes analytic bottom sediment grain
   size and density.
     \kitem{ana\_wwave}   Computes analytic wind induced wave
   amplitude, direction and period.
     \kitem{get\_bsedim}  Reads initial sediment grain size and
   density from the forcing NetCDF file.
     \kitem{get\_wwave}  Reads wind induced wave amplitude, direction
   and period from the forcing NetCDF file, and then linearly
   time-interpolates to current model time.
     \kitem{sg\_bbl96}  Computes kinematic bottom momentum stress using
   Styles and Glenn \cite{Styles96} bottom boundary layer formulation.
     \kitem{sg\_ubab}   Computes maximum wave bottom velocity and
   excursion from wind induced wave amplitude and period by
   solving the linear wave dispersion relation for a given
   wave number.
   \end{klist}
\kitem{Boundary conditions} The files \code{bcs2d.F} and \code{bcs3d.F}
contain horizontal boundary conditions for the various 2-D and 3-D
variables, respectively.  The boundary routines are also called to
specify boundary conditions on $\nabla^2 \phi$ for the horizontal
biharmonic operator on the field $\phi$.
   \begin{klist}
     \kitem{inflow} Processes prescribed inflow open boundary conditions
  from climatology data.
     \kitem{obc\_volcons} Computes integral mass flux across  all the
  open boundaries. Then, it corrects 2D velocities across to enforce
  global mass conservation.
     \kitem{t3dbc} Boundary conditions for 3-D tracer type variables.
     \kitem{u2dbc} Boundary conditions for 2-D $u$-type variables.
     \kitem{u3dbc} Boundary conditions for 3-D $u$-type variables.
     \kitem{v2dbc} Boundary conditions for 2-D $v$-type variables.
     \kitem{v3dbc} Boundary conditions for 3-D $v$-type variables.
     \kitem{w3dbc} Boundary conditions for 3-D $w$-type variables.
     \kitem{xtrbry} Extracts and loads data into boundary field
   arrays. These boundary field arrays are used in the treatment
   of the open boundaries via radiation conditions.
     \kitem{zetabc} Boundary conditions for free-surface type variables.
   \end{klist}
\kitem{Other} \mbox{}
   \begin{klist}
     \kitem{ab\_ratio}  Calculates the ratio of the thermodynamic
   expansion coefficients for potential temperature and salinity,
   alpha/beta, at horizontal and vertical $w$-points from a polynomial
   expression (Jackett and McDougall \cite{Jackett}).
     \kitem{alfabeta}  Computes thermal expansion and saline
   contraction coefficients as a function of potential temperature,
   salinity, and pressure from a polynomial expression (Jackett and
   McDougall \cite{Jackett}).
     \kitem{ana\_diag} Computes customized diagnostics.
     \kitem{ana\_meanRHO}  Analytical mean density anomaly
   (\code{rhobar}).
     \kitem{crash}    Dies in the manner appropriate for your
  computer (\code{stop} or \code{call exit}).  It also closes any open
  NetCDF files.
     \kitem{day\_code}  computes a code for the day of the week, given
    the date. This code is good for dates after January 1, 1752 AD,
    the year the Gregorian calendar was adopted in Britain and the
    American colonies.
     \kitem{diag}   Computes various diagnostic fields, such as the
  volume averaged kinetic and potential energies.
     \kitem{smol\_adv}   Evaluates horizontal and vertical advection
  terms for tracers using the  Smolarkiewicz \cite{Smolark83} advection
  scheme.  It uses  an  upstream  advection  scheme  with a  second
  corrective upstream step to reduce the implicit diffusion. An
  anti-diffusion velocity is  computed  and  used in the  second  pass
  through the advection operator.
    \begin{klist}
     \kitem{smol\_adiff}  Computes the ``anti-diffusion velocity'' used
  to suppress the  numerical  diffusion  that is associated with the
  upstream differencing operator for advection.
     \kitem{smol\_ups}   Computes a first-order upstream differencing
   operator for the 3-D advection of a tracer (scalar) field.
    \end{klist}
     \kitem{wvelocity}   Computes vertical velocity ($w$) from the
   model vertical velocity ($\Omega H_z/mn$).
   \end{klist}
\end{klist}

\subsection{C preprocessor variables}
\label{Cpp1}
Before it can be compiled, the model must be run through the C
preprocessor \code{cpp}, as described in Appendix \ref{Cpp}.  The C
preprocessor has its own variables, which may be defined either with an
explicit \code{\#define} command or with a command line option to
\code{cpp}.  We have chosen to define these variables in an include
file, \code{cppdefs.h}, except for some
machine-dependent ones, which are defined in the appropriate Makefiles.
These variables allow you to conditionally compile sections of the
code.  For instance, if \code{MASKING} is not defined then the masking
code will not be seen by the compiler, and the masking variables will
not be declared.  These \code{cpp} variables can be grouped into
several categories:
\begin{klist}
  \kitem{model test problems}  One of these can be defined to obtain
an example test problem.
  \begin{klist}
    \kitem{BASIN}      Define for the ``Big Bad Basin'' example.
    \kitem{CANYON\_A}  Define for the Canyon A (homogeneous) example.
    \kitem{CANYON\_B}  Define for the Canyon B (stratified) example.
    \kitem{GRAV\_ADJ}  Define for the gravitational adjustment example.
    \kitem{GS\_FRONT}  Define for idealized Gulf Stream front example.
    \kitem{MUNK}       Define for Stommel/Munk wind driven ocean basin.
    \kitem{OVERFLOW}   Define for the overflow example.
    \kitem{RIVERPLUME} Define for the river plume example.
    \kitem{SEAMOUNT}   Define for the seamount example.
    \kitem{SOLITON}    Define for the equatorial Rossby soliton example.
    \kitem{UPWELLING}  Define for the upwelling/downwelling
  example described in \S\ref{UpDown}.
  \end{klist}
  \kitem{momentum terms}  \mbox{}
  \begin{klist}
    \kitem{BODYFORCE}   Define to apply the surface
  stresses as a body force.
    \kitem{CURVGRID}    Define to compute the extra
  non-linear terms which arise when using curvilinear coordinates.
    \kitem{UV\_ADV}     Define to compute the momentum advection terms.
    \kitem{UV\_COR}     Define to compute the Coriolis term.
    \kitem{UV\_GSCHEME} Define for third-order upwind advection scheme.
    \kitem{UV\_PRS}     Define to compute the
  horizontal pressure gradient term.
    \kitem{UV\_PSOURCE} Define for point sources/sinks.
    \kitem{UV\_VIS2}    Define to compute the
  horizontal Laplacian viscosity.
    \kitem{UV\_VIS4}    Define to compute the
  horizontal biharmonic viscosity.
    \kitem{WJ\_PRS}     Define for weighted Jacobian pressure gradient.
  \end{klist}
  \kitem{tracers} \mbox{}
  \begin{klist}
    \kitem{DIAGNOSTIC}  Define for a diagnostic
  calculation in which the tracer fields do not change in time.
    \kitem{ICE} Define to use ice component of the model (see
       \S\ref{Iphys}.
      \begin{klist}
        \kitem{ICE\_THERMO} Define for ice thermodynamics.
      \end{klist}
    \kitem{NONLIN\_EOS} Define to use the nonlinear
  equation of state.
    \kitem{QCORRECTION}  Define to use the net heat
  flux correction.
    \kitem{SALINITY}      Define if salinity is used as one of the
  tracers.
    \kitem{SMOLARKIEWICZ} Define to compute
  Smolarkiewicz advection.
    \kitem{TS\_ADV}      Define to compute the tracer
  advection terms.
    \kitem{TS\_DIF2}     Define to compute the
  horizontal Laplacian diffusion.
    \kitem{TS\_DIF4}     Define to compute the
  horizontal biharmonic diffusion.
    \kitem{TS\_GSCHEME} Define for third-order upwind advection scheme.
    \kitem{TS\_PSOURCE} Define for point sources/sinks.
  \end{klist}
  \kitem{general model configuration} \mbox{}
  \begin{klist}
    \kitem{AVERAGES}    Define to write out time-averaged
  model fields.
    \kitem{RMDOCINC}    Define to remove documentation in
  include files with the C preprocessor.
    \kitem{SOLVE3D}     Define to solve the 3-D primitive
  equations.
    \kitem{STATIONS}    Define to write out time-series
  information at specific points in the model.
    \kitem{TIME\_AVG}   Define to average over short
  timesteps as described in \S\ref{Vort}.
  \end{klist}
  \kitem{analytic fields} \mbox{}
  \begin{klist}
    \kitem{ANA\_BMFLUX}  Define for an analytic bottom momentum stress.
    \kitem{ANA\_BSEDIM}  Define for an analytic  bottom sediment grain
  size and density.
    \kitem{ANA\_BSFLUX}  Define for an analytic bottom salt flux.
    \kitem{ANA\_BTFLUX}  Define for an analytic bottom heat flux.
    \kitem{ANA\_DIAG}    Define for customized diagnostics.
    \kitem{ANA\_GRID}    Define for an analytic model grid set-up.
    \kitem{ANA\_INITIAL} Define for analytic initial conditions.
    \kitem{ANA\_MASK}    Define for an analytic mask.
    \kitem{ANA\_MEANRHO} Define for an analytic mean density anomaly.
    \kitem{ANA\_PSOURCE} Define for analytic point sources.
    \kitem{ANA\_SMFLUX}  Define for an analytic kinematic surface
  momentum stress.
    \kitem{ANA\_SRFLUX}  Define for an analytic kinematic surface
  shortwave radiation.
    \kitem{ANA\_SSFLUX}  Define for an analytic kinematic surface
  freshwater flux.
    \kitem{ANA\_SSH}  Define for an analytic sea surface height.
    \kitem{ANA\_SST}  Define for an analytic SST and
  $\partial Q /\partial {\rm SST}$.
    \kitem{ANA\_STFLUX}  Define for an analytic kinematic surface
  heat flux.
    \kitem{ANA\_TCLIMA}  Define for an analytic tracer climatology.
    \kitem{ANA\_VMIX}    Define for analytic vertical mixing
  coefficients.
    \kitem{ANA\_WWAVE}   Define for an analytic wind induced wave
  field.
  \end{klist}
  \kitem{horizontal mixing of momentum} \mbox{}
  \begin{klist}
     \kitem{MIX\_GP\_UV}  Define for viscosity along constant $z$
   (geopotential) surfaces.
    \begin{klist}
     \kitem{MIX\_EPI\_UV}  Define for viscosity along constant {\em in
   situ} density (epineutral) surfaces.
     \kitem{MIX\_ISO\_UV}  Define for viscosity along constant potential
   density (isopycnal) surfaces.
    \end{klist}
     \kitem{MIX\_S\_UV}  Define for viscosity along constant $s$
   surfaces.
     \kitem{SMAGORINSKY} Define for Smagorinsky mixing parameterization.
     \kitem{VIS\_GRID}   Define for horizontally variable viscosity
     coefficient.
  \end{klist}
  \kitem{horizontal mixing of tracers} \mbox{}
  \begin{klist}
     \kitem{DIF\_GRID}   Define for horizontally variable diffusion
     coefficient.
     \kitem{MIX\_GP\_TS}  Define for diffusion along constant $z$
   (geopotential) surfaces.
    \begin{klist}
     \kitem{MIX\_EPI\_TS}  Define for diffusion along constant {\em in
   situ} density (epineutral) surfaces.
     \kitem{MIX\_ISO\_TS}  Define for diffusion along constant potential
   density (epineutral) surfaces.
    \end{klist}
     \kitem{MIX\_S\_TS}  Define for diffusion along constant $s$
   surfaces.
  \end{klist}
  \kitem{vertical mixing} \mbox{}
  \begin{klist}
     \kitem{BVF\_MIXING}  Define to activate Brunt-V\"ais\"al\"a
   frequency mixing.
     \kitem{LMD\_MIXING}  Define to activate Large/McWilliams/Doney
   interior closure.
    \begin{klist}
     \kitem{LMD\_CONVEC}  Define to add convective mixing due to shear
   instabilities.
     \kitem{LMD\_DDMIX}  Define to add double-diffusive mixing.
     \kitem{LMD\_KPP}  Define to add boundary layer mixing from a local
   K-Profile Parameterization (KPP).
     \kitem{LMD\_NONLOCAL} Define to add convective nonlocal transport.
     \kitem{LMD\_RIMIX}  Define to add diffusivity due to shear
   instabilities.
    \end{klist}
     \kitem{MY25\_MIXING}  Define to activate Mellor/Yamada Level-2.5
   closure.
    \begin{klist}
     \kitem{Q\_DIF2}  Define for horizontal Laplacian diffusion of
   $q$.
     \kitem{Q\_DIF4}  Define for horizontal biharmonic diffusion of
   $q$.
     \kitem{Q\_GSCHEME}  Define for third-order upwind advection of $q$.
    \end{klist}
     \kitem{PP\_MIXING}  Define to activate Pacanowski/Philander
   closure.
     \kitem{SG\_BBL96}  Define to activate Styles/Glenn bottom
   boundary layer formulation.
  \end{klist}
  \kitem{boundary conditions} \mbox{}
  \begin{klist}
     \kitem{EW\_PERIODIC}  Define for periodic boundaries in the
   \code{i} direction.
     \kitem{INFLOW2D}      Define to use SSH climatology as 2D inflow
   data.
     \kitem{INFLOW3D}      Define to process 3D inflow from tracer
   climatology.
     \kitem{NS\_PERIODIC}  Define for periodic boundaries in the
   \code{j} direction.
  \end{klist}
  \kitem{detailed eastern open boundary conditions---other sides have
similar} \mbox{}
  \begin{klist}
     \kitem{EAST\_FSGRADIENT}  Define for a gradient
   condition on the free surface.
     \kitem{EAST\_M2GRADIENT}  Define for a gradient
   condition on the 2-D momentum.
     \kitem{EAST\_M2RADIATION}  Define for a radiation
   condition on the 2-D momentum.
     \kitem{EAST\_M3GRADIENT}  Define for a gradient
   condition on the 3-D momentum.
     \kitem{EAST\_M3RADIATION}  Define for a radiation
   condition on the 3-D momentum.
     \kitem{EAST\_TGRADIENT}  Define for a gradient
   condition on the tracers.
     \kitem{EAST\_TRADIATION}  Define for a radiation
   condition on the tracers.
  \end{klist}
  \kitem{general} \mbox{}
  \begin{klist}
     \kitem{MASKING}   Define if there is land in the domain to be
   masked out.
     \kitem{M2NUDGING}     Define for nudging to 2-D momentum data.
     \kitem{M3NUDGING}     Define for nudging to 3-D momentum data.
     \kitem{TCLIMATOLOGY} Define for processing the tracer climatology arrays.
     \kitem{TNUDGING}     Define for nudging to tracer climatology.
     \kitem{ZCLIMATOLOGY} Define for processing the sea surface height
   climatology arrays.
     \kitem{ZNUDGING}     Define for nudging to sea surface height
   climatology.
  \end{klist}
  \kitem{precision}   These variables were introduced so that one
  code could be used for Crays and workstations, all using 64 bit
  precision.
  \begin{klist}
    \kitem{BIGREAL}    This is the type of all floating point
  variables used in the model computations.  It {\sl must} be defined
  to be something, such as \code{real} or \code{real*8}.  If this is
  set to \code{double precision} you should also use a compiler option
  for extending source lines past 72 characters in width.
    \kitem{DBLEPREC}     For double precision arithmetic.
%    \kitem{SMALLREAL}  This is the type of all floating point
%  variables used by the NCAR plotting routines.  It {\sl must} be
%  defined to be something, such as \code{real}.
    \kitem{FLoaT}      This is used so that the correct intrinsic
  is called, either \code{float}, \code{dfloat} or \code{real}.
    \kitem{OUT\_DOUBLE}  For double precision output.
    \kitem{NF\_FOUT}  Either \code{nf\_double} or \code{nf\_real},
  depending on \code{OUT\_DOUBLE}.
    \kitem{NF\_FTYPE}  Either \code{nf\_double} or \code{nf\_real},
  depending on model precision.
  \end{klist}
  \kitem{command line} These are defined as a command line option in
some of the \code{Makefiles} since they are machine dependent.
  \begin{klist}
    \kitem{NO\_EXIT} This will determine whether your program ends with
  a \code{stop} command or by calling \code{exit}.  I prefer
  \code{exit} on a Sun and \code{stop} on an IBM RS/6000.  The RS/6000
  will not properly close files when using \code{call exit} so it is
  possible to lose some of your output unless you use \code{stop}.

    Note that the \code{exit} subroutine on many computers does not
  require an argument.  The Sun \code{exit} subroutine uses
  the integer argument value as the return code from SCRUM for use by
  the shell under which SCRUM is run.
    \kitem{AIX} Most versions of \code{cpp} which are supplied by the
  vendor have some variables automatically defined.  For instance, on a
  SparcStation, \code{sun}, \code{unix}, and \code{sparc} will all be
  defined.  However, the RS/6000 \code{cpp} does not define anything
  useful to check for so I have the RS/6000 Makefile define
  \code{AIX}.  This is used because both the SGI and the IBM
  RS/6000 will continue to compute if some variables have become
  \code{NaN}.  In order to stop the calculation, we check for \code{NaN}
  as the error from \code{diag}, but the method of checking varies
  from one system to another.  Another system-dependent component of
  SCRUM is in the implementation of \code{get\_date}.
  \end{klist}
\end{klist}

\subsection{Important parameters}
The following is a list of the important parameters in the model.  The
rest of the parameters defined in \code{param.h} are derived from
\code{L}, \code{M}, and \code{N}.
\begin{klist}
  \kitem{isalt} Index into tracer arrays for salinity.
  \kitem{itemp} Index into tracer arrays for temperature.
  \kitem{L} Number of grid points in the $\xi$-direction.
  \kitem{M} Number of grid points in the $\eta$-direction.
  \kitem{N} Number of grid points in the vertical.
  \kitem{NS} Maximum number of output station points.
  \kitem{Nsrc} Maximum number of point sources/sinks.
  \kitem{NT} Number of tracer fields.  Often $\code{NT}=2$ for
    potential temperature and salinity.
\end{klist}
There are a lot of parameters defined in \code{pconst.h} to represent
literal constants of type \code{BIGREAL}.  It is much safer to use
the parameters when these values are needed as subroutine arguments.
The names for the constants were chosen based on the following
``rules'':
\begin{itemize}
  \item Use a prefix of \code{c} for whole real numbers (\code{c0} for
    zero and \code{c1} for 1.0).
  \item Use a prefix of \code{p} for non repeating fractions
    (\code{p5} for 0.5).
  \item Use a prefix of \code{r} for reciprocals (\code{r3} for 1.0/3.0
    and \code{r10} for 0.1 which could also be \code{p1}).
  \item Combine use of the prefix and \code{e} for scientific notation
    (\code{c1e4} for $1.0e+4$ and \code{c1em4} for $1.0e-4$).
  \item Use names when appropriate (\code{pi} for
    $\pi = 3.14159265\ldots$).
\end{itemize}

\subsection{Modules}
Now that we are using Fortran 90, the method of choice for managing
data structures are modules. The \code{ROMS/Modules} directory
contains all of the ROMS modules that contain globally used
variables. The complete list is:
\begin{klist}
  \kitem{mod\_arrays.F} This actually has no data structures, but is the
    routine that calls the allocate and initialize routines for all the
    others.
  \kitem{mod\_average.F} If \code{AVERAGES} is #defined, this will
    provide the storage for the running means of the fields you are averaging.
  \kitem{mod\_bbl.F}  If \code{BBL\_MODEL} is #defined, this will
    provide the storage for the bottom boundary fields.
  \kitem{mod\_biology.F}  If \code{BIOLOGY} is #defined, this will
    provide the storage for the biology interaction parameters.
  \kitem{mod\_boundary.F} This contains the storage for the open boundary
    conditions. If they aren't provided analytically, this will also provide
    the storage for fields read from a file that need to be time-interpolated.
  \kitem{mod\_clima.F}  If one of \code{CLIMATOLOGY}, \code{AD\_SENSITIVITY},
    \code{OPT\_OBSERVATIONS}, or \code{SO\_SEMI} is #defined, this will
    provide the storage for the climatological fields.
  \kitem{mod\_coupler.F}  If either \code{MODEL\_COUPLING}  or
    \code{ESMF\_LIB} is #defined, this will set up the requisite fields and
    data structures for the coupling.
  \kitem{mod\_coupling.F}  If \code{SOLVE3D} is #defined, this will
    provide the storage for the fields used in coupling the 2-D
    and 3-D components of the simulation.
  \kitem{mod\_diags.F}  If \code{DIAGNOSTICS} is #defined, this will
    provide the storage for the various tendency terms.
  \kitem{mod\_eclight.F}  If both \code{BIOLOGY} and \code{ECOSIM}
    are #defined, this will set up the spectral irradiance
    variables.
  \kitem{mod\_eoscoef.F}  If \code{NONLIN\_EOS} is #defined, this will
    provide the polynomial expansion coefficients for the nonlinear equation
    of state for sea water.
  \kitem{mod\_floats.F} If \code{FLOATS} is #defined, this will
    provide the storage for the float tracking variables.
  \kitem{mod\_forces.F} This
    provides the storage for the surface and bottom forcing fields.
  \kitem{mod\_fourdvar.F} If either \code{FOUR\_DVAR} or \code{VERIFICATION}
    is #defined, this will set up the variational data assimilation
    variables.
  \kitem{mod\_grid.F} This provides the storage for the model grid fields. 
    provide the storage for the running means of the fields.
  \kitem{mod\_iounits.F} This contains a number of variables used by the
    I/O, including file names and file IDs.
  \kitem{mod\_kinds.F}  This contains the integers associated with the
    various integer and real Fortran types. If you find more systems
    supporting 128-bit reals, let us know.
  \kitem{mod\_mixing.F} This contains the arrays for the horizontal and
    vertical mixing parameterizations, including those used by the various
    optional schemes.
  \kitem{mod\_ncparam.F} This contains all sorts of parameters relating to
    the NetCDF I/O files, including that read from the \code{varinfo.dat}
    file. The parameter \code{MT} is set here, giving the maximum number of
    variables that can be read.
  \kitem{mod\_nesting.F} If \code{NESTING} is #defined, this module defines
    generic structures used for nesting, composed, and mosaic grids.
  \kitem{mod\_netcdf.F} This brings in \code{netcdf.mod} and defines a few
    type variables based on it.
  \kitem{mod\_obs.F} If either \code{ASSIMILATION} or \code{NUDGING}
    is #defined, this contains variables for the observed fields.
  \kitem{mod\_ocean.F} This contains the 2-D and 3-D fields of the primitive
  ocean variables and optionally the sediment variables.
  \kitem{mod\_parallel.F} This sets up some global variables such as
    \code{Master}, which is true for the master thread or
    process. It also initializes the internal ROMS profiling arrays.
  \kitem{mod\_param.F} This contains the sizes of each grid used, plus
    things like how many tidal constituents are being used. Many of these are
    read from the input files during initialization, not known at compile
    time.
  \kitem{mod\_scalars.F} This contains a large number of scalars, i.e. values
    which don't have spatial dependence. Some are fixed constants such
    as \code{itemp} refering to the temperature tracer. Others could
    have a different value on each grid.
  \kitem{mod\_sediment.F} If either \code{SEDIMENT} or \code{BBL\_MODEL}
    is #defined, this contains parameters for the respective model.
  \kitem{mod\_sources.F} If one of \code{UV\_PSOURCE}, \code{TS\_PSOURCE}
    or \code{Q\_PSOURCE} is #defined, this contains the variables used
    for point sources.
  \kitem{mod\_stepping.F} This contains the timestepping variables used to
    point to the relevant time level.
  \kitem{mod\_storage.F} If \code{PROPAGATOR} is
    #defined, this module defines the work space for the Generalized
    Stability Theory (GST) Analysis package (ARPACK).
  \kitem{mod\_strings.F} This contains strings such as a title for the run,
    the list of '''cpp''' options defined, and the names of the sections of
    code being profiled.
  \kitem{mod\_tides.F}  If \code{AVERAGES} is #defined, this will
    provide the storage for the running means of the fields.
\end{klist}
